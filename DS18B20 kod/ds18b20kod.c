//************************************************************************************
//**  
//**  File name:     C:\Users\pc\OneDrive\Downloads\Dzenit Vildic-Projeler (1)\Dzenit Vildic-Projeler\DS18B20 sicaklik sensoru\DS18B20 kod\ds18b20kod.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.1.0.0
//**  Date:          Thursday, September 26, 2024 15:33:22
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 1
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F877
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_30
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 10000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x3f7a
#endif
#ifdef HI_TECH_C
__CONFIG(0x3f7a);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_Pozdravna_poruka();


//Variable declarations
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_UINT8 FCV_PWPLUS;
MX_UINT8 FCV_TEMPDEC;
MX_UINT8 FCV_SETPOINT;
MX_SINT16 FCV_TEMP;
MX_UINT8 FCV_TEMPINT;
MX_UINT8 FCV_PWMINUS;




//LCDDisplay(0): //Defines:

/**** Macro Substitutions ****
a = Unique Component Reference Number
b = D1 Port Letter
c = D2 Port Letter
d = D3 Port Letter
e = D4 Port Letter
f = RS Port Letter
g = E Port Letter
h = Data 1_Pin
i = Data 2 Pin
j = Data 3 Pin
k = Data 4 Pin
l = RS Pin
m = Enable Pin
n = Row Count
o = Column Count
******************************/

	//component connections
	#define LCD_1__PORT0    portb
	#define LCD_1__PORT1    portb
	#define LCD_1__PORT2    portb
	#define LCD_1__PORT3    portb
	#define LCD_1__PORT4    portb
	#define LCD_1__PORT5    portb
	#define LCD_1__TRIS0    trisb
	#define LCD_1__TRIS1    trisb
	#define LCD_1__TRIS2    trisb
	#define LCD_1__TRIS3    trisb
	#define LCD_1__TRIS4    trisb
	#define LCD_1__TRIS5    trisb
	#define LCD_1__BIT0    	4
	#define LCD_1__BIT1    	5
	#define LCD_1__BIT2    	6
	#define LCD_1__BIT3    	7
	#define LCD_1__RS      	2
	#define LCD_1__E       	3
	#define LCD_1__ROWCNT	2
	#define LCD_1__COLCNT	16

	#ifdef _BOOSTC
	  #define LCD_1__DELAY   delay_10us(10)
	#endif
	#ifdef _C2C_
	  #define LCD_1__DELAY   delay_us(100)
	#endif
	#ifdef HI_TECH_C
	  #define LCD_1__DELAY   __delay_us(120)
	#endif
	#ifndef LCD_1__DELAY
	  #define LCD_1__DELAY   delay_us(100)
	#endif




//LCDDisplay(0): //Macro function declarations

void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask);
void FCD_LCDDisplay0_Start();
void FCD_LCDDisplay0_Clear();
void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character);
void FCD_LCDDisplay0_Command(MX_UINT8 in);
void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y);
void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number);
void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String);
void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions);
void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line);
void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7);


//One_Wire(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = CRC Check Enable (0-Off / 1-On)
c = One Wire Port Register
d = One Wire Pin
******************************/

//Global Definitions

#define 	ONEWIRE_2_OO_CRC_EN  			0
#define 	ONEWIRE_2_OO_PORT  			porta
#define 	ONEWIRE_2_OO_TRIS 				trisa
#define 	ONEWIRE_2_OO_PIN  				1

//I/O for the OO
#define 	ONEWIRE_2_Float_OO 			FC_CAL_Bit_In_DDR( ONEWIRE_2_OO_PORT , ONEWIRE_2_OO_TRIS , ONEWIRE_2_OO_PIN )
#define 	ONEWIRE_2_Clear_OO				FC_CAL_Bit_Low_DDR( ONEWIRE_2_OO_PORT , ONEWIRE_2_OO_TRIS , ONEWIRE_2_OO_PIN )

#ifndef OO_DEFS
 #define OO_DEFS

 // 1. ROM function commands
 #define		OO_READROM        	0x33
 #define   		OO_MATCHROM       	0x55
 #define  		OO_SKIPROM        	0xCC
 #define		OO_SEARCHROM      	0xF0
 #define		OO_ALARMSEARCH    	0xEC

 // 2. Memory Command Functions
 #define		OO_WRITEPAD       	0x4E
 #define		OO_READPAD        	0xBE
 #define		OO_COPYPAD        	0x48
 #define		OO_CONVERTT       	0x44
 #define		OO_RECALLE2			0xB8
 #define		OO_READSUPPLY		0xB4

#endif

//CRC lookup table for the OO - Only include once for all 1-wire components
#if OO_CRC_EN == 1
  #ifndef OO_CRC_ROM
	#define OO_CRC_ROM

	ROMARRAY_S OO_CRC_ROM ROMARRAY_E = {0, 94, 188, 226, 97, 63, 221, 131, 194, 156, 126, 32, 163, 253, 31, 65,
									157, 195, 33, 127, 252, 162, 64, 30, 95, 1, 227, 189, 62, 96, 130, 220,
									35, 125, 159, 193, 66, 28, 254, 160, 225, 191, 93, 3, 128, 222, 60, 98,
									190, 224, 2, 92, 223, 129, 99, 61, 124, 34, 192, 158, 29, 67, 161, 255,
									70, 24, 250, 164, 39, 121, 155, 197, 132, 218, 56, 102, 229, 187, 89, 7,
									219, 133, 103, 57, 186, 228, 6, 88, 25, 71, 165, 251, 120, 38, 196, 154,
									101, 59, 217, 135, 4, 90, 184, 230, 167, 249, 27, 69, 198, 152, 122, 36,
									248, 166, 68, 26, 153, 199, 37, 123, 58, 100, 134, 216, 91, 5, 231, 185,
									140, 210, 48, 110, 237, 179, 81, 15, 78, 16, 242, 172, 47, 113, 147, 205,
									17, 79, 173, 243, 112, 46, 204, 146, 211, 141, 111, 49, 178, 236, 14, 80,
									175, 241, 19, 77, 206, 144, 114, 44, 109, 51, 209, 143, 12, 82, 176, 238,
									50, 108, 142, 208, 83, 13, 239, 177, 240, 174, 76, 18, 145, 207, 45, 115,
									202, 148, 118, 40, 171, 245, 23, 73, 8, 86, 180, 234, 105, 55, 213, 139,
									87, 9, 235, 181, 54, 104, 138, 212, 149, 203, 41, 119, 244, 170, 72, 22,
									233, 183, 85, 11, 136, 214, 52, 106, 43, 117, 151, 201, 74, 20, 246, 168,
									116, 42, 200, 150, 21, 75, 169, 247, 182, 232, 10, 84, 215, 137, 107, 53};
  #endif

	// CRC working variable
	MX_UINT8 		ONEWIRE_2_oo_crc = 0;

#endif

//Global Variables

// Internal variables
MX_UINT8        ONEWIRE_2_oo_id[8];
MX_SINT8 		ONEWIRE_2_oo_conflict;
MX_UINT8        ONEWIRE_2_oo_new_conflict;

// Device ID Variables
MX_UINT8 		ONEWIRE_2_oo_num_devices = 0;
MX_UINT8 		ONEWIRE_2_oo_DevID[64] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
								0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

// Scratchpad Variables
MX_UINT8 		ONEWIRE_2_oo_scratchpad[9];

// Scratchpad contents DS1820
// 0	Temperature LSB
// 1	Temperature MSB
// 2	Hi alarm temperature
// 3	Lo alarm temperature
// 4	Reserved, 0xFF
// 5	Reserved, 0xFF
// 6	Remainder register
// 7	Nr of counts per degree
// 8	CRC of pad contents




//One_Wire(0): //Macro function declarations

void FCD_One_Wire0_oo_crc_shuffle_byte(MX_UINT8 input);
void FCD_One_Wire0_oo_crc_init();
MX_UINT8 FCD_One_Wire0_rx_bit();
void FCD_One_Wire0_tx_bit(MX_UINT8 out);
MX_UINT8 FCD_One_Wire0_oo_get_next_id();
MX_UINT8 FCD_One_Wire0_oo_busreset();
MX_UINT8 FCD_One_Wire0_oo_get_pad_byte(MX_UINT8 index);
void FCD_One_Wire0_oo_tx_byte(MX_UINT8 data);
MX_UINT8 FCD_One_Wire0_oo_rx_byte();
MX_UINT8 FCD_One_Wire0_oo_scanbus();
MX_UINT8 FCD_One_Wire0_oo_get_devicecount();
MX_UINT8 FCD_One_Wire0_oo_read_device(MX_UINT8 count);
MX_UINT8 FCD_One_Wire0_oo_get_IDByte(MX_UINT8 device, MX_UINT8 octet);
MX_UINT8 FCD_One_Wire0_DS1820_start_conversion();
MX_UINT8 FCD_One_Wire0_DS1820_read_scratchpad();
MX_UINT16 FCD_One_Wire0_DS1820_get_temp();


//EEPROM(0): //Defines:

/**** Macro Substitutions ****
Component has no substitutions
******************************/

#ifndef MX_EEPROM_REF
	#define MX_EEPROM_REF

	extern MX_UINT8 FC_CAL_EE_Read (MX_UINT16 Address);
	extern void FC_CAL_EE_Write (MX_UINT16 Address, MX_UINT8 Data);

#endif




//EEPROM(0): //Macro function declarations

MX_UINT16 FCD_EEPROM0_EEPROMRead(MX_UINT16 addr);
void FCD_EEPROM0_WriteEEPROM(MX_UINT16 addr, MX_UINT16 data);



//LCDDisplay(0): //Macro implementations


void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask)
{
	
		MX_UINT8 pt;

		FC_CAL_Bit_Low(LCD_1__PORT0, LCD_1__BIT0);
		FC_CAL_Bit_Low(LCD_1__PORT1, LCD_1__BIT1);
		FC_CAL_Bit_Low(LCD_1__PORT2, LCD_1__BIT2);
		FC_CAL_Bit_Low(LCD_1__PORT3, LCD_1__BIT3);
		FC_CAL_Bit_Low(LCD_1__PORT4, LCD_1__RS);
		FC_CAL_Bit_Low(LCD_1__PORT5, LCD_1__E);
		pt = ((in >> 4) & 0x0f);
		if (pt & 0x01)
		    FC_CAL_Bit_High(LCD_1__PORT0, LCD_1__BIT0);
		if (pt & 0x02)
		    FC_CAL_Bit_High(LCD_1__PORT1, LCD_1__BIT1);
		if (pt & 0x04)
		    FC_CAL_Bit_High(LCD_1__PORT2, LCD_1__BIT2);
		if (pt & 0x08)
		    FC_CAL_Bit_High(LCD_1__PORT3, LCD_1__BIT3);
		if (mask)
		    FC_CAL_Bit_High(LCD_1__PORT4, LCD_1__RS);
		LCD_1__DELAY;
		FC_CAL_Bit_High (LCD_1__PORT5, LCD_1__E);
		LCD_1__DELAY;
		FC_CAL_Bit_Low (LCD_1__PORT5, LCD_1__E);
		pt = (in & 0x0f);
		LCD_1__DELAY;
		FC_CAL_Bit_Low(LCD_1__PORT0, LCD_1__BIT0);
		FC_CAL_Bit_Low(LCD_1__PORT1, LCD_1__BIT1);
		FC_CAL_Bit_Low(LCD_1__PORT2, LCD_1__BIT2);
		FC_CAL_Bit_Low(LCD_1__PORT3, LCD_1__BIT3);
		FC_CAL_Bit_Low(LCD_1__PORT4, LCD_1__RS);
		FC_CAL_Bit_Low(LCD_1__PORT5, LCD_1__E);
		if (pt & 0x01)
		    FC_CAL_Bit_High(LCD_1__PORT0, LCD_1__BIT0);
		if (pt & 0x02)
		    FC_CAL_Bit_High(LCD_1__PORT1, LCD_1__BIT1);
		if (pt & 0x04)
		    FC_CAL_Bit_High(LCD_1__PORT2, LCD_1__BIT2);
		if (pt & 0x08)
		    FC_CAL_Bit_High(LCD_1__PORT3, LCD_1__BIT3);
		if (mask)
		    FC_CAL_Bit_High(LCD_1__PORT4, LCD_1__RS);
		LCD_1__DELAY;
		FC_CAL_Bit_High (LCD_1__PORT5, LCD_1__E);
		LCD_1__DELAY;
		FC_CAL_Bit_Low (LCD_1__PORT5, LCD_1__E);
		LCD_1__DELAY;

}

void FCD_LCDDisplay0_Start()
{
	
		FC_CAL_Bit_Low_DDR(LCD_1__PORT0, LCD_1__TRIS0, LCD_1__BIT0);
		FC_CAL_Bit_Low_DDR(LCD_1__PORT1, LCD_1__TRIS1, LCD_1__BIT1);
		FC_CAL_Bit_Low_DDR(LCD_1__PORT2, LCD_1__TRIS2, LCD_1__BIT2);
		FC_CAL_Bit_Low_DDR(LCD_1__PORT3, LCD_1__TRIS3, LCD_1__BIT3);
		FC_CAL_Bit_Low_DDR(LCD_1__PORT4, LCD_1__TRIS4, LCD_1__RS);
		FC_CAL_Bit_Low_DDR(LCD_1__PORT5, LCD_1__TRIS5, LCD_1__E);

		Wdt_Delay_Ms(12);

		FCD_LCDDisplay0_RawSend(0x33, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x33, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x32, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x2c, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x06, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x0c, 0);
		Wdt_Delay_Ms(2);

		//clear the display
		FCD_LCDDisplay0_RawSend(0x01, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x02, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Clear()
{
	
		FCD_LCDDisplay0_RawSend(0x01, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x02, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character)
{
	
		FCD_LCDDisplay0_RawSend(Character, 0x10);

}

void FCD_LCDDisplay0_Command(MX_UINT8 in)
{
	
		FCD_LCDDisplay0_RawSend(in, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y)
{
	
	  #if (LCD_1__ROWCNT == 1)
	    y=0x80;
	  #endif

	  #if (LCD_1__ROWCNT == 2)
		if (y==0)
			y=0x80;
		else
			y=0xc0;
	  #endif

	  #if (LCD_1__ROWCNT == 4)
		if (y==0)
			y=0x80;
		else if (y==1)
			y=0xc0;

		#if (LCD_1__COLCNT == 16)
			else if (y==2)
				y=0x90;
			else
				y=0xd0;
		#endif

		#if (LCD_1__COLCNT == 20)
			else if (y==2)
				y=0x94;
			else
				y=0xd4;
		#endif
	  #endif

		FCD_LCDDisplay0_RawSend(y+x, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number)
{
	
		MX_SINT16 tmp_int;
		MX_UINT8 tmp_byte;

		if (Number < 0)
		{
			FCD_LCDDisplay0_RawSend('-', 0x10);
			Number = 0 - Number;
		}

		tmp_int = Number;
		if (Number >= 10000)
		{
			tmp_byte = tmp_int / 10000;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10000;
				tmp_byte--;
			}
		}
		if (Number >= 1000)
		{
			tmp_byte = tmp_int / 1000;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 1000;
				tmp_byte--;
			}
		}
		if (Number >= 100)
		{
			tmp_byte = tmp_int / 100;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 100;
				tmp_byte--;
			}
		}
		if (Number >= 10)
		{
			tmp_byte = tmp_int / 10;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10;
				tmp_byte--;
			}
		}
		FCD_LCDDisplay0_RawSend('0' + tmp_int, 0x10);

}

void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String)
{
	
		MX_UINT8 idx = 0;

		for (idx=0; idx<MSZ_String; idx++)
		{
			if (String[idx] == 0)
			{
				break;
			}
			FCD_LCDDisplay0_RawSend(String[idx], 0x10);
		}

}

void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions)
{
	
		MX_UINT8 cmd = 0;
		MX_UINT8 count;

		//Choose the direction
		switch (Direction)
		{
			case 0:
			case 'l':
			case 'L':

				cmd = 0x18;
				break;

			case 1:
			case 'r':
			case 'R':

				cmd = 0x1C;
				break;

			default:
				break;
		}

		//If direction accepted then scroll the specified amount
		if (cmd)
		{
			for (count = 0; count < Num_Positions; count++)
				FCD_LCDDisplay0_Command(cmd);
		}

}

void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line)
{
	
		MX_UINT8 count;
		MX_UINT8 rowcount;

		//Define number of columns per line
		#if (LCD_1__ROWCNT == 1)
			rowcount=80;
		#endif

		#if (LCD_1__ROWCNT == 2)
			rowcount=40;
		#endif

		#if (LCD_1__ROWCNT == 4)
			#if (LCD_1__COLCNT == 16)
				rowcount=16;
			#endif
			#if (LCD_1__COLCNT == 20)
				rowcount=20;
			#endif
		#endif

		//Start at beginning of the line
		FCD_LCDDisplay0_Cursor (0, Line);

		//Send out spaces to clear line
		for (count = 0; count < rowcount; count++)
			FCD_LCDDisplay0_RawSend(' ', 0x10);

		//Move back to the beginning of the line.
		FCD_LCDDisplay0_Cursor (0, Line);

}

void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7)
{
	   //set CGRAM address

	   FCD_LCDDisplay0_RawSend(64 + (nIdx << 3), 0);
	   delay_ms(2);

	   //write CGRAM data
	   FCD_LCDDisplay0_RawSend(d0, 0x10);
	   FCD_LCDDisplay0_RawSend(d1, 0x10);
	   FCD_LCDDisplay0_RawSend(d2, 0x10);
	   FCD_LCDDisplay0_RawSend(d3, 0x10);
	   FCD_LCDDisplay0_RawSend(d4, 0x10);
	   FCD_LCDDisplay0_RawSend(d5, 0x10);
	   FCD_LCDDisplay0_RawSend(d6, 0x10);
	   FCD_LCDDisplay0_RawSend(d7, 0x10);

	   //Clear the display
	   FCD_LCDDisplay0_RawSend(0x01, 0);
	   delay_ms(2);
	   FCD_LCDDisplay0_RawSend(0x02, 0);
	   delay_ms(2);

}



//One_Wire(0): //Macro implementations


void FCD_One_Wire0_oo_crc_shuffle_byte(MX_UINT8 input)
{
	
		#if OO_CRC_EN == 1
			ONEWIRE_2_oo_crc = OO_CRC_ROM[ONEWIRE_2_oo_crc ^ input];
		#endif

}

void FCD_One_Wire0_oo_crc_init()
{
	
		#if OO_CRC_EN == 1
			ONEWIRE_2_oo_crc = 0;
		#endif

}

MX_UINT8 FCD_One_Wire0_rx_bit()
{
	
		MX_UINT8 oo_bit, count;
		ONEWIRE_2_Clear_OO;						//Clear Output Pin
		delay_us(1);						//Delay 1us
		ONEWIRE_2_Float_OO;						//Float Output Pin
		delay_us(10);						//Delay 10us
		oo_bit = FC_CAL_Bit_In( ONEWIRE_2_OO_PORT , ONEWIRE_2_OO_PIN );				//Test Input
		delay_us(50);						//Delay 50us
		return oo_bit;

}

void FCD_One_Wire0_tx_bit(MX_UINT8 out)
{
	
		MX_UINT8 count;
		ONEWIRE_2_Clear_OO;						//Clear Output Pin
		delay_us(1);						//Delay 1us
		if (out & 0x01)
			ONEWIRE_2_Float_OO;					//Float Output Pin
		delay_us(60);						//Delay 60us
		ONEWIRE_2_Float_OO;						//Float Output Pin
		delay_us(10);						//Delay 10us

}

MX_UINT8 FCD_One_Wire0_oo_get_next_id()
{
	
		MX_UINT8 val0 = 0;
		MX_UINT8 val1 = 0;
		MX_UINT8 counter    = 0;
		MX_UINT8 bit_index  = 0;
		MX_UINT8 byte_index = 0;
		MX_UINT8 data_in_byte = 0;
		//MX_UINT8 current_ONEWIRE_2_oo_conflict = -1;

		//added JCMB 10/01/09
		MX_UINT8 lz_selected = 0;
		MX_UINT8 go_on = 0;
		MX_UINT8 bit_test;

		ONEWIRE_2_oo_new_conflict = 0;

		if ( FCD_One_Wire0_oo_busreset() )	// Reset the bus
		{
			return 1; // -> error
		}
		// Issue the search ROM command
		FCD_One_Wire0_oo_tx_byte(OO_SEARCHROM);

		// Start the search for the sensor
		for (byte_index = 0; byte_index < 8; byte_index++)
		{
			data_in_byte = 0;
			for (bit_index = 0; bit_index < 8; bit_index++)
			{
				// Read 2 consecutive bits from the One Wire bus
				val0 = FCD_One_Wire0_rx_bit();						//Test Input
				val1 = FCD_One_Wire0_rx_bit();						//Test Input

				// Evaluate the result
				if ((val0 == 0) && (val1 == 0))
				{
					//current_ONEWIRE_2_oo_conflict = counter;
					// if ONEWIRE_2_oo_conflict occurs earlier than the previous ONEWIRE_2_oo_conflict, then use the previous value
					if (counter < ONEWIRE_2_oo_conflict)
					{
						// use previous value
						bit_test = ONEWIRE_2_oo_id[byte_index] >> bit_index;		//added JCMB 10/01/09
						if (bit_test & 0x01)
						{
							val0 = 1;
						}
						else
						{
							val0 = 0;
							lz_selected = counter;				//added JCMB 10/01/09
							go_on = 1;							//added JCMB 10/01/09
						}
					}
					else if (counter == ONEWIRE_2_oo_conflict)
					{
						// use 1
						val0 = 1;
					}
					else
					{
						// use zero on new ONEWIRE_2_oo_conflicts
						val0 = 0;
						ONEWIRE_2_oo_conflict = counter;
						ONEWIRE_2_oo_new_conflict = 1;
					}
				}
				else if (val0 && val1) // 1 et 1 impossible
				{
					return 2;
				}
				// Store the bit in the ID array
				data_in_byte = data_in_byte >> 1;
				if (val0)
				{
					data_in_byte |= 0x80;
				}

				FCD_One_Wire0_tx_bit(val0);

				counter++;
			}
			ONEWIRE_2_oo_id[byte_index] = data_in_byte;
		}

	        //added JCMB 10/01/09
		if ((ONEWIRE_2_oo_new_conflict == 0) && go_on)
		{
			ONEWIRE_2_oo_new_conflict = 1;
			ONEWIRE_2_oo_conflict = lz_selected ;
		}

		// Verify ID CRC
		#if OO_CRC_EN == 1
			FCD_One_Wire0_oo_crc_init();
		#endif

		for (byte_index = 0; byte_index < 8; byte_index++)
		{
			#if OO_CRC_EN == 1
					FCD_One_Wire0_oo_crc_shuffle_byte(ONEWIRE_2_oo_id[byte_index]);
			#endif
		}
		// Bail on CRC errors
	  #if OO_CRC_EN == 1
		if (ONEWIRE_2_oo_crc) return ONEWIRE_2_oo_crc;
	  #endif
		return 0;

}

MX_UINT8 FCD_One_Wire0_oo_busreset()
{
	
		ONEWIRE_2_Float_OO; 					// Release bus
		ONEWIRE_2_Clear_OO;					// Send the reset pulse
		delay_us(200);					// Wait for 600 µs, this is the reset pulse
		delay_us(200);
		delay_us(200);
		ONEWIRE_2_Float_OO; 					// Release bus
		delay_us(60);					// Wait 60 us (release) let device drive the bus
		if (FC_CAL_Bit_In( ONEWIRE_2_OO_PORT, ONEWIRE_2_OO_PIN ) == 1)			// Now sample, if there is a sensor on the bus, the line should be low
			return 1; 					// <<-error
		delay_us(140);					// Wait another 540 us to complete the reset sequence
		delay_us(200);
		delay_us(200);
		return 0;

}

MX_UINT8 FCD_One_Wire0_oo_get_pad_byte(MX_UINT8 index)
{
	
		return ONEWIRE_2_oo_scratchpad[index];

}

void FCD_One_Wire0_oo_tx_byte(MX_UINT8 data)
{
	
		MX_UINT8 counter = 0;
		while (counter < 8)
		{
			FCD_One_Wire0_tx_bit(data);
			data = data >> 1;				//Rotate to next bit of data
			counter++;						//Increment Counter
		}

}

MX_UINT8 FCD_One_Wire0_oo_rx_byte()
{
	
		MX_UINT8 counter = 0;
		MX_UINT8 data    = 0;
		MX_UINT8 oo_bit  = 0;
		while (counter < 8)
		{
			oo_bit = FCD_One_Wire0_rx_bit();
			data = data >> 1;					//Shift incoming data to next bit
			if (oo_bit > 0)
			{
				data = data | 0x80;				//Append incoming bit to data byte
			}
			counter++;							//Increment Counter
		}
		#ifdef OO_OO_CRC_EN
			FCD_One_Wire0_oo_crc_shuffle_byte(data);			//Check CRC
		#endif
		return data;

}

MX_UINT8 FCD_One_Wire0_oo_scanbus()
{
	
		MX_UINT8 retval = 0;
		MX_UINT8 device_count = 0;
		MX_UINT8 loper;
		ONEWIRE_2_oo_conflict = -1;
		ONEWIRE_2_oo_new_conflict = 1;
		// Reset the bus, wake up devices.
		retval = FCD_One_Wire0_oo_busreset();
		if (retval == 1)
		{
			return 255; // -> error
		}
		// ONEWIRE_2_oo_new_conflict gets updated in the FCD_One_Wire0_oo_get_next_id() function.
		while (ONEWIRE_2_oo_new_conflict)
		{
			retval = FCD_One_Wire0_oo_get_next_id();
			// Bail in case of errors
			if (retval) return retval;
			// Add the device ONEWIRE_2_oo_id to EEPROM
			for (loper=0; loper < 8; loper++)
			{
				ONEWIRE_2_oo_DevID[loper+(device_count<<3)] = ONEWIRE_2_oo_id[loper];
			}
			device_count++;
		}
		// Write number of devices to the EEPROM
		ONEWIRE_2_oo_num_devices = device_count;
		return 0;

}

MX_UINT8 FCD_One_Wire0_oo_get_devicecount()
{
	
		return ONEWIRE_2_oo_num_devices;

}

MX_UINT8 FCD_One_Wire0_oo_read_device(MX_UINT8 count)
{
	
		MX_UINT8 loper = 0;
		MX_UINT8 counter = 0;
		MX_UINT8 temp;
		MX_UINT16 value;

		FCD_One_Wire0_oo_busreset();
		FCD_One_Wire0_oo_tx_byte(OO_MATCHROM);
		for (loper=0; loper < 8; loper++)
		{
			ONEWIRE_2_oo_DevID[loper] = ONEWIRE_2_oo_id[loper+(count<<3)];
			FCD_One_Wire0_oo_tx_byte(ONEWIRE_2_oo_id[loper]);
		}
		FCD_One_Wire0_oo_tx_byte(OO_READPAD);
		#if OO_CRC_EN == 1
			FCD_One_Wire0_oo_crc_init();			//Reset the CRC register, CRC is updated in the FCD_One_Wire0_oo_rx_byte() function.
		#endif
		while (counter < 9)
		{
			temp = FCD_One_Wire0_oo_rx_byte();
			ONEWIRE_2_oo_scratchpad[counter] = temp;
			counter++;
		}
		#if OO_CRC_EN == 1
			return ONEWIRE_2_oo_crc;				//Verify the CRC
		#endif
		return 0;

}

MX_UINT8 FCD_One_Wire0_oo_get_IDByte(MX_UINT8 device, MX_UINT8 octet)
{
	
		MX_UINT8 retval = 255;

		if ((device >= ONEWIRE_2_oo_num_devices) | (octet > 7))
		{
			return retval ; //error
		}
	        retval = ONEWIRE_2_oo_DevID[octet+(device<<3)];
		return retval ;

}

MX_UINT8 FCD_One_Wire0_DS1820_start_conversion()
{
	
		MX_UINT8 in = 0;
		MX_UINT8 counter = 0;

		FCD_One_Wire0_oo_busreset();
		FCD_One_Wire0_oo_tx_byte(OO_SKIPROM);		// Command all temp sensors on the bus to start a conversion
		FCD_One_Wire0_oo_tx_byte(OO_CONVERTT);	// Convert temperature
		while (in == 0)
		{
			in = FCD_One_Wire0_oo_rx_byte();
			delay_ms(4);
			counter++;
			if (counter == 0xFF)		// Security: if the conversion is not completed
				return 1;				// after > 1 sec -> break.
		}
		return 0;

}

MX_UINT8 FCD_One_Wire0_DS1820_read_scratchpad()
{
	
		MX_UINT8 temp;
		MX_UINT8 counter = 0;

		if ( FCD_One_Wire0_oo_busreset() )
			return (1);
		FCD_One_Wire0_oo_tx_byte(OO_SKIPROM);		//Command all temp sensors on the bus to start a conversion
		FCD_One_Wire0_oo_tx_byte(OO_READPAD);		//Convert temperature
		#if OO_CRC_EN == 1
			FCD_One_Wire0_oo_crc_init();			//Reset the CRC register, CRC is updated in the FCD_One_Wire0_oo_rx_byte() function.
		#endif
		while (counter < 9)
		{
			temp = FCD_One_Wire0_oo_rx_byte();
			ONEWIRE_2_oo_scratchpad[counter] = temp;
			counter++;
		}
		#if OO_CRC_EN == 1
			return ONEWIRE_2_oo_crc;				//Verify the CRC
		#endif
		return 0;

}

MX_UINT16 FCD_One_Wire0_DS1820_get_temp()
{
	
		MX_UINT16 retval;
		retval = ONEWIRE_2_oo_scratchpad[1];
		retval = retval << 8;
		retval = retval | ONEWIRE_2_oo_scratchpad[0];
		return retval;

}



//EEPROM(0): //Macro implementations


MX_UINT16 FCD_EEPROM0_EEPROMRead(MX_UINT16 addr)
{
	
		return (FC_CAL_EE_Read (addr));

}

void FCD_EEPROM0_WriteEEPROM(MX_UINT16 addr, MX_UINT16 data)
{
	
		FC_CAL_EE_Write (addr, data);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_Pozdravna_poruka()
{

	//Call Component Macro
	//Call Component Macro: Cursor(3, 0)
	FCD_LCDDisplay0_Cursor(3, 0);

	//Call Component Macro
	//Call Component Macro: PrintString("REGULATOR")
	FCD_LCDDisplay0_PrintString("REGULATOR", 9);

	//Call Component Macro
	//Call Component Macro: Cursor(2, 1)
	FCD_LCDDisplay0_Cursor(2, 1);

	//Call Component Macro
	//Call Component Macro: PrintString("TEMPERATURE")
	FCD_LCDDisplay0_PrintString("TEMPERATURE", 11);

	//Delay
	//Delay: 2 s
	delay_s(2);

	//Call Component Macro
	//Call Component Macro: Clear()
	FCD_LCDDisplay0_Clear();

	//Call Component Macro
	//Call Component Macro: Cursor(0, 0)
	FCD_LCDDisplay0_Cursor(0, 0);

	//Call Component Macro
	//Call Component Macro: PrintString("SA SONDOM")
	FCD_LCDDisplay0_PrintString("SA SONDOM", 9);

	//Call Component Macro
	//Call Component Macro: Cursor(0, 1)
	FCD_LCDDisplay0_Cursor(0, 1);

	//Call Component Macro
	//Call Component Macro: PrintString("DS18B20")
	FCD_LCDDisplay0_PrintString("DS18B20", 7);

	//Delay
	//Delay: 2 s
	delay_s(2);

	//Call Component Macro
	//Call Component Macro: Clear()
	FCD_LCDDisplay0_Clear();

}



void main()
{
	//Initialization
	adcon1 = 0x07;


	//Interrupt initialization code
	option_reg = 0xC0;


	//Call Component Macro
	//Call Component Macro: Start()
	FCD_LCDDisplay0_Start();

	//Calculation
	//Calculation:
	//  setPoint = 20
	//  temp = 0
	//  tempDec = 0
	//  tempInt = 0
	//  pwplus = 1
	//  pwminus = 1
	FCV_SETPOINT = 20;
	FCV_TEMP = 0;
	FCV_TEMPDEC = 0;
	FCV_TEMPINT = 0;
	FCV_PWPLUS = 1;
	FCV_PWMINUS = 1;

	//Call Component Macro
	//Call Component Macro: SetPoint=Read(0)
	FCV_SETPOINT = FCD_EEPROM0_EEPROMRead(0);

	//Call Macro
	//Call Macro: Pozdravna_poruka()
	FCM_Pozdravna_poruka();

	//Loop
	//Loop: While 1
	while (1)
	{

		//Call Component Macro
		//Call Component Macro: DS1820_start_conversion()
		FCD_One_Wire0_DS1820_start_conversion();

		//Call Component Macro
		//Call Component Macro: DS1820_read_scratchpad()
		FCD_One_Wire0_DS1820_read_scratchpad();

		//Call Component Macro
		//Call Component Macro: temp=DS1820_get_temp()
		FCV_TEMP = FCD_One_Wire0_DS1820_get_temp();

		//Calculation
		//Calculation:
		//  tempInt = temp / 16
		//  tempDec = (temp MOD 16) * 625
		FCV_TEMPINT = FCV_TEMP / 16;
		FCV_TEMPDEC = (FCV_TEMP % 16) * 625;

		//Call Component Macro
		//Call Component Macro: Cursor(0, 0)
		FCD_LCDDisplay0_Cursor(0, 0);

		//Call Component Macro
		//Call Component Macro: PrintString("TEMP:")
		FCD_LCDDisplay0_PrintString("TEMP:", 5);

		//Call Component Macro
		//Call Component Macro: PrintNumber(tempInt)
		FCD_LCDDisplay0_PrintNumber(FCV_TEMPINT);

		//Call Component Macro
		//Call Component Macro: PrintString(".")
		FCD_LCDDisplay0_PrintString(".", 1);

		//Call Component Macro
		//Call Component Macro: PrintNumber(tempDec)
		FCD_LCDDisplay0_PrintNumber(FCV_TEMPDEC);

		//Call Component Macro
		//Call Component Macro: PrintASCII(176)
		FCD_LCDDisplay0_PrintASCII(176);

		//Call Component Macro
		//Call Component Macro: PrintString("C")
		FCD_LCDDisplay0_PrintString("C", 1);

		//Call Component Macro
		//Call Component Macro: Cursor(0, 1)
		FCD_LCDDisplay0_Cursor(0, 1);

		//Call Component Macro
		//Call Component Macro: PrintString("PW:")
		FCD_LCDDisplay0_PrintString("PW:", 3);

		//Call Component Macro
		//Call Component Macro: PrintNumber(SetPoint)
		FCD_LCDDisplay0_PrintNumber(FCV_SETPOINT);

		//Decision
		//Decision: tempInt >= setPoint?
		if (FCV_TEMPINT >= FCV_SETPOINT)
		{

			//Output
			//Output: 0 -> C0
			trisc = trisc & 0xFE;
			if ((0))
				portc = (portc & 0xFE) | 0x01;
			else
				portc = portc & 0xFE;

		} else {

			//Output
			//Output: 1 -> C0
			trisc = trisc & 0xFE;
			if ((1))
				portc = (portc & 0xFE) | 0x01;
			else
				portc = portc & 0xFE;

		}

		//Delay
		//Delay: 500 ms
		delay_ms(255);
		delay_ms(245);

		//Input
		//Input: D0 -> pwplus
		trisd = trisd | 0x01;
		FCV_PWPLUS = ((portd & 0x01) == 0x01);

		//Decision
		//Decision: pwplus = 0?
		if (FCV_PWPLUS == 0)
		{

			//Calculation
			//Calculation:
			//  setPoint = setPoint + 1
			FCV_SETPOINT = FCV_SETPOINT + 1;

			//Call Component Macro
			//Call Component Macro: Cursor(0, 1)
			FCD_LCDDisplay0_Cursor(0, 1);

			//Call Component Macro
			//Call Component Macro: PrintString("PW:")
			FCD_LCDDisplay0_PrintString("PW:", 3);

			//Call Component Macro
			//Call Component Macro: PrintNumber(SetPoint)
			FCD_LCDDisplay0_PrintNumber(FCV_SETPOINT);

			//Call Component Macro
			//Call Component Macro: Write(0, SetPoint)
			FCD_EEPROM0_WriteEEPROM(0, FCV_SETPOINT);

			//Loop
			//Loop: While pwplus = 0
			while (FCV_PWPLUS == 0)
			{

				//Input
				//Input: D0 -> pwplus
				trisd = trisd | 0x01;
				FCV_PWPLUS = ((portd & 0x01) == 0x01);


			}

		// } else {

		}

		//Input
		//Input: D1 -> pwminus
		trisd = trisd | 0x02;
		FCV_PWMINUS = ((portd & 0x02) == 0x02);

		//Decision
		//Decision: pwminus = 0?
		if (FCV_PWMINUS == 0)
		{

			//Calculation
			//Calculation:
			//  setPoint = setPoint - 1
			FCV_SETPOINT = FCV_SETPOINT - 1;

			//Call Component Macro
			//Call Component Macro: Cursor(0, 1)
			FCD_LCDDisplay0_Cursor(0, 1);

			//Call Component Macro
			//Call Component Macro: PrintString("PW:")
			FCD_LCDDisplay0_PrintString("PW:", 3);

			//Call Component Macro
			//Call Component Macro: PrintNumber(SetPoint)
			FCD_LCDDisplay0_PrintNumber(FCV_SETPOINT);

			//Call Component Macro
			//Call Component Macro: Write(0, SetPoint)
			FCD_EEPROM0_WriteEEPROM(0, FCV_SETPOINT);

			//Loop
			//Loop: While pwminus = 0
			while (FCV_PWMINUS == 0)
			{

				//Input
				//Input: D1 -> pwminus
				trisd = trisd | 0x02;
				FCV_PWMINUS = ((portd & 0x02) == 0x02);


			}

		// } else {

		}


	}

	mainendloop: goto mainendloop;
}

void MX_INTERRUPT_MACRO(void)
{
}



